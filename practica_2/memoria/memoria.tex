%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DOCUMENT PREAMBLE %%%
\documentclass[12pt]{report}
\usepackage[spanish]{babel}
\usepackage{float}
\usepackage{listings}
%\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
 
%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
numbers=left, % where to put the line-numbers; possible values are (none, left, right)
numbersep=5pt, % how far the line-numbers are from the code
numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%
 
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
 
%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}
 

\title{Práctica 2 - Arquitectura y prototipo del proyecto del grupo UniTools}					
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}


% Title
\author{- A.W.}						
% Author
\date{today's date}
% Date

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
   % \includegraphics[scale = 0.075]{bsulogo.png}\\[1.0 cm]	% University Logo
\begin{center}    \textsc{\Large  APLICACIONES WEB}\\[2.0 cm]	\end{center}% University Name
	\textsc{\Large Memoria del Proyecto }\\[0.5 cm]				% Course Code
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
		%	\emph{Submitted To:}\\
		%	Name\\
          % Affiliation\\
           %contact info\\
			\end{flushleft}
			\end{minipage}~
			\begin{minipage}{0.4\textwidth}
            
			\begin{flushright} \large
			\emph{Miembros del grupo :} \\
			Luis Cepeda, Carlos Bilbao,
			Hugo Ribeiro, Daniel Canseco,
			Fernando Ruiz, Bruno Mayo
			
		\end{flushright}
           
	\end{minipage}\\[2 cm]
	
	\includegraphics[scale = 0.15]{UniTools.png}

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\thesection}{\arabic{section}}
\section{Descripción general de la práctica}

En esta memoria, describiremos cómo hemos decidido estructurar nuestra página web llegado este punto de su desarollo.  Se trata de una práctica importante para nosotros, ya que su desarollo y las decisiones que tomáramos iban a condiciar el resto de las prácticas. Es decir, la estructura general, así como la Base de Datos y las abstraciones que empleamos van a servirnos como base en sucesivas versiones.

Durante esta práctica hemos centrado nuestros esfuerzos en dos aspectos:

\begin{enumerate}  
\item Organizar nuestra página web haciendo uso de \textbf{un esquema que divide en cuatro partes (cabecera, navegación ó menú, contenido y pie)}, siendo el contenido el único actualizado dinámicamente, en función de las peticiones recbidas. 

A continuación, hemos dividido entre scripts de vista, de apoyo y de lógica. Esta distribución ha resultado ser muy provechosa y nos ha permitido avanzar más agilmente. Además, hemos ahorrado muchas líneas de código gracias a ella.

\item Desarrollar tres funcionalidades principales. Para comenzar a darle forma a nuestra web, hemos elegido por un lado funcionalidades esenciales: Es decir, sin ellas lo demás no sería posible, este es el caso de \textbf{Login y Registro}. 

Al mismo tiempo, hemos desarrollado otras dos funcionalidades que, sin depender otras de ellas, planteaban también un reto técnico. Estas han sido Herramientas \textbf{y más importante, Foro}.

\end{enumerate}

\textbf{Todo esto se ha hecho utilizando el patrón DAO (dao/), mediate clases.}

Hemos seguido la estructura de carpetas explicada en la teoría de la asignatura. Hemos creado un usuario extra para la Base de Datos (aparte del propio root, con total acceso) con diferentes permisos y privilegios, así como una tabla extra en la Base de Datos, como log de los accesos fallidos en el Login. La contraseña se ha encriptado con Bcrypt y un hash para mayor seguridad. 
\newline

A la hora de dividir el trabajo, decidimos dejar a cada miembro del equipo encargado de dirigir cada una de las partes. Dicho lo cual, hemos hecho un esfuerzo por realizar videollamadas semanalmente para coordinar el trabajo y asegurarnos de que todos estábamos al corriente del funcionamiento de lo demás. Hemos utilizado GitHub para gestionar las versiones y commits del proyecto. \textbf{El código mostrado en esta memoria, podría no estar completamente actualizado debido a pequeños cambios para pulir detalles, no obstante la idea general explicada será la misma en cualquier caso}.
\newpage
\section{Scripts para las vistas}
Las vistas posibles de esta versión son entre las que permite navegar el Menú de la página web, aunque algunas de ellas no mostrarán ningún contenido si el usuario no ha sido previamente registrado.
\begin{itemize}
    \item (scripts/perfil.php) Perfil incluye ya toda la información del usuario, incluido si se trata de un usuario Premium.
    \item (scripts/proyectos.php) Proyectos permitirá a los estudiantes subir código de sus proyectos.
    \item (scripts/foro.php) \textbf{Foro permite a los usuarios postear mensajes}.
    \item (scripts/mensajes.php) Mensajes requerirá estar loggeado.
    \item (scripts/herramientas.php) \textbf{Herramientas incluye algunas utilidades para los estudiantes} a modo de funcionalidades. En esta versión hemos añadido varias, que serán explicadas luego.
    \item (scripts/login.php) Login permite iniciar sesión al usuario, tal y como se explicará más tarde. 
    \item (scripts/registro.php) Registrar permite crear un nuevo usuario, mediante una conexión a la Base de Datos, como se explicará a continuación.
\end{itemize}

En realidad, en nuestro portal sólo se accede a una página, que es index.php, cuyo código se muestra a continuación. Se ha incluido un caso condicional para hacer \textit{session\_start()}, para que en el caso que el usuario se acabe de conectar ó su sesión haya caducado, se puedan restaurar las variables globales.

Después, utilizando \textit{require()} se incluyen las partes que toda vista debe tener: cabecera (estructura/cabecera.php), navegación (estructura/menu.php), un contenido (del que ahora se hablará) y  un pie de página (estructura/pie.php).
\newline
\begin{lstlisting}[language=HTML]
<?php
    if(!isset($_SESSION)) 
    { 
        session_start(); 
    } 
?>
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="../css/hoja.css">
    <title>INDEX</title>
    <meta charset="UTF-8">
</head>
<body>
<div id="contenedor">
    <?php 
        require("cabecera.php") ;
	 	require("navegacion.php") ;
	?>
	<div id="contenido">
	   <?php require("contenido.php");?>
	</div>
	<?php 
	 	require("pie.php") ;
	?>
</div> <!-- Fin del contenedor -->
</body>
\end{lstlisting}

Por tanto, lo único que cambiará según cual sea la vista es el contenido, administrado en estructura/contenido.php, el cual no solo se encarga de cambiar el contenido en función de la petición que le llegue, sino que además realiza el control de seguridad para comprobar que el usuario ha sido correctamente loggeado, y en caso contrario no mostrarle dicho contenido.

Para ilustrar esto, asumamos que alguien que no está ni siquiera loggeado intenta acceder a un contenido sólo disponible para administradores, manipulando la petición en la url para acceder a admin.php (Es decir, escribe \textit{index.php?page=admin}). En ese caso, tal y como se muestra en el siguiente código, contenido.php no le dejará acceder tras comprobar con los parámetros de la variable global SESSION que, efectivamente, ni era administrador ni había iniciado sesión.
\newline
\begin{lstlisting}[language=HTML]
<?php 

if(isset($_GET["page"])) {
    (...)
    
  else if($_GET["page"] == "admin") {
    
    if ((!isset($_SESSION["login"]))&&(!isset($_SESSION["esAdmin"]))) {
            echo "<p>No puedes ver este contenido, tienes que estar loggeado y ser Administrador para visualizarlo.</p>";
    }
\end{lstlisting}

Otra funcionalidad que hemos implementado es \textbf{Herramientas}, en \textit{script/herramientas.php}. Se trata de una serie de utilidades sencillas que quisimos añadir para prácticar nuestra programación en JavaScript y al mismo tiempo proveer de alguna herramienta que puedan encontrar nuestros compañeros interesante. 

Por ahora, se han implementado cuatro herramientas:
\begin{enumerate}
    \item Un formateador de palabras.
    \item Un contador de palabras.
    \item Un conversor de decimal a hexadecimal.
    \item Un conversor de decimal a binario.
    \item Un conversor de binario a decimal.
\end{enumerate}
Todos salvo el primero son sencillas funciones de JavaScript cuyo desarrollo no merece la pena explicar. Lo único reseñable es que las tres últimas se han implementado, en realidad, con la misma función pero distintos parámetros.

La herramienta más interesante es la primera, ya que para ella se ha hecho uso de \textbf{Canvas}, que permite dibujar gráficas y similares en JavaScript como se muestra.

\begin{figure}[h]
    \subfloat{{\includegraphics[width=7cm]{canvas.png} }}%
    \qquad
    \subfloat{{\includegraphics[width=7.3cm]{canvas2.png} }}%
    \label{fig:example}%
\end{figure}

\begin{lstlisting}[language=JavaScript]
var c = document.getElementById("myCanvas");
var ctx = c.getContext("2d");
ctx.font = "italic small-caps 30px Verdana";
ctx.strokeText("Ejemplo",30,70);
function texto(){
        $str = document.getElementById('valor_d4').value;
        ctx.clearRect(0,0,c.width,c.height).fillText($str, 30, 70);
        alert("Palabra cambiada!");
}
\end{lstlisting}

La otra funcionalidad y la principal de esta práctica es el Foro, gestionado mediante el patrón de diseño DAO. Una vez un usuario se ha registrado e iniciado sesión, puede \textbf{tanto revisar la lista de Posts publicados como escribir un nuevo Posts}, con scripts/post.php.

Para mostrar los posts del foro, basta con usar los DAO, que realizan unas queries a la Base de Datos que ordenan las entradas por antigüedad, cosa que se puede hacer sin problema gracias a los id, que ascienden automáticamente. Una vez se tienen los Transfer Object de las entradas, estas pueden asociarse al TO del usuario, para luego crear una tabla con su información (id y Nombre de Usuario).
\newline

\begin{lstlisting}[language=PHP]
<?php   
        include_once("dao/dao_user.php");
        include_once("dao/dao_post.php");
     
        $foro_data = new TOUpost();
        $dao_post = new DAOpost();
        $dao_user = new DAOUsuario();
        $res = $dao_post->show_all_data();
        
        while(!empty($res)){
            $curr_post = array_shift($res);
            $user_id = $curr_post->get_user(); // id del usuario 
            $usuario = $dao_user->search_userId($user_id);
            (...)
            echo "<table class=\"posts\">";
	          echo "<tbody>";
		        echo "<tr>";
			      echo "<td>ID del post:".$curr_post->get_id()."</td>";
            (...)
            echo "</table>";       
        } 
        $dao_user->disconnect();
        $dao_post->disconnect();
    ?>
\end{lstlisting}

Publicar entradas en el foro es un poco más intrincado, ya que requiere coger el texto escrito por el usuario y realizar una inserción en la Base de Datos. El DAO hace:
\newline

\begin{lstlisting}[language=SQL]
$sql = sprintf("INSERT INTO posts(user,title,content,category) 
		    VALUES ('$user', '$title', '$content', '$category')");
$result = $this->ejecutarConsulta($sql);
\end{lstlisting}
La conexión a la Base de Datos tendrá que hacerse con los permisos necesarios para insertar, por lo que hemos decidido dar al usuario no root permisos de inserción. De todo ello se hablará más detenidamente en el Capítulo dedicado a la BBDD. El "padre" de los DAO es el encargado de gestionar la conexión.
\newline
\begin{lstlisting}[language=PHP]
<?php

class DAO {

 public $conn;
	
   public function __construct() {

	if (!$this->conn){
		
		$this->conn = mysqli_connect("localhost", "root", "", "unitoolsdb");
		
		if( mysqli_connect_error ()){
			 die ("Conexion con la base de datos fallida : " . mysqli_connect_error());
		}	 
    (...)
?>
\end{lstlisting}

Y luego las clases DAO heredan de éste:
\newline
\begin{lstlisting}[language=PHP]
<?php

include_once('DAO.php');
include_once('user_class.php');

/* Data Access Object */
class DAOUsuario extends DAO {

	public function __construct(){
		parent::__construct();
	}

	public function insert_User($TOUser){
		$mail = $TOUser->get_email();
        $pass = $TOUser->get_password();
        $username = $TOUser->get_username();
        $premium =  $TOUser->get_premium();
		$sql = "INSERT INTO user SET email='$mail' , password='$pass', username='$username', premium='$premium'";
		
		if (!$this->insertarConsulta($sql))
			return false;
		else 
		{
			return true;
		}
	}
\end{lstlisting}

Y utilizan los Transfer Object como "moneda de cambio" de la información:
\newline
\begin{lstlisting}[language=PHP]
<?php

/* Transfer Object */
class TOUser {

	private $userId;
	private $email;
	private $password;
	private $user_name;
	private $premium;

	function __construct($userId='',$email='',$password='',$user_name='',$premium=''){
		$this->userId = $userId;
		$this->email = $email;
		$this->password = $password;
		$this->user_name = $user_name;
		$this->premium = $premium;
	}
	(...)
?>
\end{lstlisting}
Además, ya hemos montado la versión básica del Perfil, tal y como se muestra a continuación.

\includegraphics[scale = 0.6]{Perfil_unitools.png}

 \newpage
\section{Scripts adicionales}
Dos scripts que es importante mencionar son el de Login y el de Registro, ambos estrechamente ligados con la Base de Datos que será después descrita. 

El contenido de scripts/registrar.php es simplemente un form sencillo, cuya action es procesarRegistro.php, en la misma carpeta. A continuación se describirán algunas de las partes más importantes de este script.

Primero, se crean variables que serán utilizadas para la conexión con la Base de Datos. Estas son los campos de la tabla usuario, que fueron previamente rellenados en registro.php. Además, se utilizan las funciones \textit{trim} y \textit{strip\_tags} para hacer "sanitize" del input. Esto incluye eliminar espacios, e \textbf{impedir que el usuario introduzca código malicioso en las entradas}.
\newline
\begin{lstlisting}[language=PHP]
$servername = "localhost";
$username =  htmlspecialchars(trim(strip_tags($_REQUEST["username"])));
$email = htmlspecialchars(trim(strip_tags($_REQUEST["email"])));
$password = htmlspecialchars(trim(strip_tags($_REQUEST["password"])));
$nick = htmlspecialchars(trim(strip_tags($_REQUEST["nick"])));
$rol = ($_REQUEST["rol"]);
$Premium = ($_REQUEST["premium"]);
require_once 'connectdb.php';
\end{lstlisting}

Acabado esto, toca conectarse a la Base de Datos, utilizando la última línea del código anterior, que llama a connectdb.php. En este script se intentará conectar a la Base de Datos,
especificando el nombre del servidor, el usuario y la Base de Datos. Para evitar que un estudiante cualesquiera pueda modificar las tablas de la Base de Datos, \textbf{este acceso se lleva a cabo con el nombre de un usuario con pocos privilegios}.
\newline
\begin{lstlisting}[language=PHP]
<?php
 $conn = mysqli_connect("localhost", "usuario1", "", "unitoolsdb");
 if( mysqli_connect_error ()){
     die ("Acceso a BBDD fallido : " . mysqli_connect_error());
 }else{ echo "Connected successfully";   }
?>
\end{lstlisting}
Una vez se haya establecido la conexión, el script procesarRegistro.php podrá realizar una query e incluir al usuario en las tablas de la Base de Datos. No obstante, esto lo hará tras primero comprobar que se ha podido conectar a la Base de Datos satisfactoriamente. Como se puede comprobar a continuación, la petición SQL se trata de una sencilla inserción en la tabla user, utilizando todas las variables que fueron previamente revisadas.

\begin{lstlisting}[language=PHP]
$sql = "INSERT INTO 
 user(id_User, email, password, Nick, Rol, Premium) 
 VALUES('$username','$email','$password','$nick','$rol','$Premium')";
if ($conn->query($sql) === TRUE) {
           echo "New record created successfully";
} else { echo "Error: " . $sql . "<br>" . $conn->error;  }  
\end{lstlisting}

El script de procesarLogin.php es muy similar. Se reciben los valores que han sido introducidos en el form de login.php y estos se utilzan para realizar la query. Eso si, como era de esperar en esta ocasión la petición SQL no es una inserción, sino un SELECT que comprueba que los valores son idénticos.
\newline
\begin{lstlisting}[language=PHP]
$query = mysqli_query($conn, 
    "SELECT * FROM user 
    WHERE Nick='$username' 
    AND password='$password'");

if(!$query){ 
    echo mysqli_error($conn);
        // Si falla la consulta, mejor no seguir ejecutando.
        exit;
} 

// Validamos los datos introducidos en el login
if($user = mysqli_fetch_assoc($query)) {
        $conn->close();
        $_SESSION['access_success'] = $username;
        header("Location:index.php");
} else {
        $_SESSION['access_error'] = '1';
        header("location: login.php");
}
\end{lstlisting}

Como se puede apreciar en la línea 19, se emplea una variable global para marcar que el acceso ha fracasado en caso de que los datos sean erroneos, y otra para la situación opuesta. Estas variables son luego revisadas por login.php, que llamó a procesarLogin.php, para saber si ha devuelto un valor la petición.
\newline
\begin{lstlisting} [language=PHP]
<?php
 if(isset($_SESSION['access_error'])){
    $try =  $_SESSION['access_error'];
    if($try == '1'){
        echo "\n";
        echo " <h3> <font color = 'red'> Datos incorrectos.</font> </h3>";
        $_SESSION['access_error'] = '0';
        }
    }
\end{lstlisting}

\newpage
\section{Estructura de la Base de Datos}
A continuación repasaremos la estructura que hemos seguido para nuestra Base de Datos inicial, apoyándonos en PhpMyAdmin. Para ello, hemos decidido diseñar e incluir dos módelos muy utilizados para la definición de las BBDD, el Modelo Relacional y el Modelo Entidad Relación, de más alto nivel. También hablaremos de cómo hemos gestionado los permisos.
\newline


\includegraphics[scale = 0.6]{UnitoolsER.png}

Como se puede ver, la Base de Datos consta de seis tablas: User,Repository, Logs,Posts,Respuesta y Categories. Cada una de ellas con su clave primaria y relacionada con otra (u otras, en el caso de User). 

Además, se pueden apreciar las restricciones de cantidad. Un usuario puede crear N repositorios, así como generar N logs de fallos y publicar N posts en un foro. Todas las relaciones son para con el Usuario y de tipo (1,N). Desgraciadamente, \textbf{esta información se pierde al traducir el Modelo ER a un modelo relacional}, por culpa de las limitaciones inherentes al segundo. Este segundo esquema quedaría entonces como se muestra a continuación.
\newline

\includegraphics[scale = 0.7]{UniToolsDB.png}

Estas cuatro tablas luego son pobladas en nuestra Base de Datos, los ids son incrementados por orden de apariencia y estos no pueden ser nulos, tal y como se puede apreciar en el siguiente código.

Además, como puede apreciarse en el código mostrado abajo, se han añadido restricciones para las foreign key y políticas CASCADE para las actualizaciones.
\newline

\begin{lstlisting} [language=SQL]
--
-- AUTO_INCREMENT de la tabla `repository`
--
ALTER TABLE `repository`
  MODIFY `id_rep` int(11) NOT NULL AUTO_INCREMENT;
(...)
--
-- Filtros para la tabla `repository`
--
ALTER TABLE `repository`
  ADD CONSTRAINT `repository_ibfk_1` FOREIGN KEY (`creator`) REFERENCES `user` (`id_User`) ON UPDATE CASCADE;
COMMIT;
\end{lstlisting}

Además, hemos tenido que tener en mente los permisos para hacer una Base de Datos segura y restrictiva. Para eso, hemos decidido usar \textbf{dos cuentas de usuarios}.

Los permisos del usuario root son los que eran de esperar, totales. La siguiente imagen muestra una captura de pantalla de los parámetros utilizados en PhpMyAdmin para añadir al usuario root con total privilegio y permisos de acceso.

Como se puede ver, el usuario root tiene todos los permisos tanto desde un punto de vista de Administración , como de Estructura (crear,alterar entradas...), y Datos para realizar queries a la Base de Datos (Seleccionar, Insertar, Actualizar, Eliminar, etc).


\includegraphics[scale = 0.5]{root.jpg}

Por otro lado, los privilegios del usuario normal (\textbf{usuario1}) son mucho más limitados, como se puede ver debajo. En este caso, la contraseña que usamos para el usuario normal es unitoolsdb.

\includegraphics[scale = 0.5]{user.png}

La BBDD (disponible en \textbf{\textit{DataBase/unitoolsdb.sql}}) se complicará y crecerá en sucesivas prácticas. Dicho esto, consideramos que la estructura inicial, así como el sistema de privilegios por el que hemos optado, son un buen punto de partida y no esperamos grandes cambios ni re-estructuraciones completas.

\end{document}
